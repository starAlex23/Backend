<!DOCTYPE html>
<html lang="de" data-theme="light">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Zeiterfassung</title>

  <!-- Manifest einbinden -->
  <link rel="manifest" href="/manifest.json" />

  <!-- Theme- und Hintergrundfarbe -->
  <meta name="theme-color" content="#1976d2" />

  <!-- PWA-Unterst√ºtzung -->
  <meta name="mobile-web-app-capable" content="yes" /> <!-- f√ºr Android / moderne Browser -->
  
  <!-- Optional iOS weiterhin unterst√ºtzen -->
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="apple-mobile-web-app-title" content="StempelApp" />

  <!-- Fallback: icon f√ºr iOS -->
  <link rel="apple-touch-icon" href="/icons/icon-192.png" />
  
<style>
/* =======================================
   üåó BASIS + THEME
======================================= */
:root {
  /* Globale Farben */
  --bg: #fff;
  --fg: #000;
  --card-bg: #f9f9f9;
  --border: #ccc;
  
  /* App Akzente */
  --accent: #4CAF50;       /* Haupt-Gr√ºn */
  --accent-hover: #43a047;
  
  /* Chat Spezifisch */
  --chat-primary: #4CAF50; /* Chat Header */
  --chat-bg-main: #e5ddd5; /* WhatsApp-artiger Hintergrund */
  --chat-bg-msg-in: #ffffff;
  --chat-bg-msg-out: #dcf8c6; /* Helles Gr√ºn f√ºr eigene */
  --chat-border: #ddd;
}

[data-theme="dark"] {
  --bg: #121212;
  --fg: #eee;
  --card-bg: #1c1c1c;
  --border: #444;

  /* Dark Mode Chat */
  --chat-primary: #1f2c34;
  --chat-bg-main: #0b141a;
  --chat-bg-msg-in: #1f2c34;
  --chat-bg-msg-out: #005c4b;
  --chat-border: #2a3942;
}

/* =======================================
   üî§ BASISLAYOUT
======================================= */
html, body {
  margin: 0;
  padding: 0;
  max-width: 100vw;
  overflow: hidden; /* Wichtig f√ºr App-Feeling */
  font-family: 'Inter', sans-serif;
  font-size: 16px;
  line-height: 1.6;
  background: var(--bg);
  color: var(--fg);
  height: 100vh; /* Fixierte H√∂he */
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
}

.hidden { display: none !important; }

/* =======================================
   üì¶ MAIN + CONTAINER
======================================= */
main, #app-view, #auth-container {
  flex-grow: 1;
  width: 100%;
  box-sizing: border-box;
  overflow-y: auto; /* Inhalt scrollt hier */
  padding: 1rem;
  padding-bottom: 80px; /* Platz f√ºr Bottom Nav */
  position: relative;
}

/* =======================================
   üß≠ HEADER
======================================= */
header {
  background: var(--accent);
  color: #fff;
  padding: 0.8rem 1rem;
  display: flex;
  align-items: center;
  gap: 0.6rem;
  font-size: 1.2rem;
  font-weight: 600;
  position: sticky;
  top: 0;
  z-index: 1100;
  box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  flex-shrink: 0;
}

header .app-title {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex-grow: 1;
}

/* =======================================
   ü™™ CARD STIL
======================================= */
.card {
  background: var(--card-bg);
  padding: 1.5rem 1.8rem;
  margin-bottom: 1.5rem;
  border-radius: 12px;
  box-shadow: 0 2px 8px rgb(0 0 0 / 0.15);
  transition: box-shadow 0.2s ease, transform 0.2s ease;
}

/* =======================================
   üßæ FORM ELEMENTE
======================================= */
label { display: block; margin-top: 1rem; font-weight: 500; }

input[type="email"], input[type="password"], input[type="text"] {
  width: 100%;
  padding: 0.8rem;
  margin-top: 0.4rem;
  border-radius: 6px;
  border: 1px solid var(--border);
  background: var(--bg);
  color: var(--fg);
  box-sizing: border-box;
}

input:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 2px rgba(76,175,80,0.2);
}

/* =======================================
   üîò BUTTONS
======================================= */
button {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  margin-top: 1.2rem;
  padding: 0.8rem 1.4rem;
  font-size: 1rem;
  border-radius: 10px;
  background: var(--accent);
  color: white;
  border: none;
  cursor: pointer;
  box-shadow: 0 4px 6px rgba(0,0,0,0.1);
  transition: all 0.2s ease;
}

button:hover:not(:disabled) {
  background: var(--accent-hover);
  transform: translateY(-1px);
}

button:disabled { background: #999; cursor: not-allowed; }

/* =======================================
   üì± BOTTOM NAVIGATION
======================================= */
#bottom-nav {
  position: fixed;
  bottom: 0; left: 0; right: 0;
  height: 60px;
  display: flex;
  justify-content: space-around;
  background: var(--bg);
  border-top: 1px solid var(--border);
  box-shadow: 0 -1px 6px rgba(0, 0, 0, 0.05);
  z-index: 1000;
  padding-bottom: env(safe-area-inset-bottom); /* F√ºr iPhone X+ */
}

#bottom-nav button {
  background: none;
  border: none;
  color: #888;
  padding: 0;
  margin: 0;
  box-shadow: none;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  position: relative;
  width: 100%;
}

#bottom-nav button:hover { transform: none; color: var(--accent); }
#bottom-nav button.active { color: var(--accent); }

/* =======================================
   üîÑ LOADING SPINNER
======================================= */
#loading-overlay {
  position: fixed; inset: 0;
  background: rgba(255,255,255,0.8);
  backdrop-filter: blur(2px);
  display: flex; align-items: center; justify-content: center;
  z-index: 9999;
}
.spinner {
  width: 48px; height: 48px;
  border: 5px solid #ccc;
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }

/* ==========================================================
   üí¨ MOBILE CHAT STYLING (FIXED)
   ========================================================== */

/* Container Reset: √úberschreibt .card Styles f√ºr Fullscreen-Look */
.mobile-chat-app {
    /* Layout Reset um das Padding von <main> zu kontern */
    margin: -1rem !important; 
    width: calc(100% + 2rem) !important;
    height: calc(100vh - 55px - 60px) !important; /* Viewport - Header - BottomNav */
    
    /* Reset Card Styles */
    background: var(--bg) !important;
    box-shadow: none !important;
    border-radius: 0 !important;
    padding: 0 !important;
    
    position: relative;
    overflow: hidden;
    display: flex;
}

/* ---------------------------------
   1. CHAT-LISTE / SIDEBAR 
   --------------------------------- */
.chat-sidebar {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0; left: 0;
    background: var(--bg);
    display: flex;
    flex-direction: column;
    z-index: 10;
}

.chat-sidebar-header {
    padding: 1rem;
    background: var(--bg);
    font-size: 1.1rem;
    font-weight: bold;
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
}

.chat-sidebar-list {
    flex-grow: 1;
    overflow-y: auto;
    list-style: none;
    padding: 0;
    margin: 0;
}

.chat-sidebar-item {
    padding: 1rem;
    border-bottom: 1px solid var(--border);
    cursor: pointer;
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.chat-sidebar-item:hover,
.chat-sidebar-item.active {
    background: rgba(0,0,0,0.05); /* Dezenter Hover */
}
[data-theme="dark"] .chat-sidebar-item:hover { background: rgba(255,255,255,0.05); }

.chat-title { font-weight: 600; font-size: 1rem; }
.chat-preview { font-size: 0.85rem; color: #888; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }


/* ---------------------------------
   2. CHAT-ANSICHT / MAIN 
   --------------------------------- */
.chat-main {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0; left: 0;
    background-color: var(--chat-bg-main);
    /* Optional: Hintergrundbild Muster wie bei WhatsApp */
    background-image: linear-gradient(rgba(255,255,255,0.9), rgba(255,255,255,0.9)); 
    display: flex;
    flex-direction: column;
    z-index: 20;
    
    /* Animation Slide-In */
    transform: translateX(100%); 
    transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
}

[data-theme="dark"] .chat-main {
    background-image: none; 
}

/* Aktiv-Zustand */
.chat-main.active {
    transform: translateX(0);
}

/* Chat Header */
.chat-main .chat-header {
    padding: 0.8rem 1rem;
    background: var(--chat-primary);
    color: white;
    font-size: 1.1rem;
    font-weight: 600;
    display: flex;
    align-items: center;
    flex-shrink: 0;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

.chat-main .back-btn {
    background: transparent;
    border: none;
    color: white;
    font-size: 1.4rem;
    cursor: pointer;
    margin: 0 10px 0 0;
    padding: 0;
    width: auto;
    box-shadow: none;
}

/* Nachrichten Bereich */
.chat-messages {
    flex-grow: 1;
    overflow-y: auto;
    padding: 1rem;
    list-style: none;
    margin: 0;
    display: flex;
    flex-direction: column;
    gap: 8px;
    scroll-behavior: smooth;
}

.message {
    display: flex;
    width: 100%;
}

.message-content {
    max-width: 80%;
    padding: 8px 12px;
    line-height: 1.4;
    font-size: 0.95rem;
    position: relative;
    box-shadow: 0 1px 1px rgba(0,0,0,0.1);
    word-wrap: break-word;
}

.message p { margin: 0; }

/* Eigene Nachrichten (Rechts) */
.message.user { justify-content: flex-end; }

.message.user .message-content {
    background: var(--chat-bg-msg-out);
    color: #000; /* WhatsApp Text ist dunkel, auch bei gr√ºnem Hintergrund */
    border-radius: 7.5px 7.5px 0 7.5px; /* Ecke unten rechts eckig */
}
[data-theme="dark"] .message.user .message-content { color: #fff; }

/* Fremde Nachrichten (Links) */
.message.other { justify-content: flex-start; }

.message.other .message-content {
    background: var(--chat-bg-msg-in);
    color: var(--fg);
    border-radius: 0 7.5px 7.5px 7.5px; /* Ecke oben links eckig */
}

/* Input-Bereich */
.chat-input-area {
    display: flex;
    align-items: flex-end;
    padding: 8px 10px;
    background: var(--bg);
    border-top: 1px solid var(--chat-border);
    flex-shrink: 0;
    gap: 8px;
}

#chat-input-field {
    flex-grow: 1;
    padding: 10px 14px;
    border-radius: 20px;
    border: 1px solid var(--border);
    background: var(--bg);
    color: var(--fg);
    resize: none;
    font-family: inherit;
    font-size: 1rem;
    max-height: 100px;
    min-height: 42px;
    line-height: 1.3;
}

#chat-input-field:focus {
    border-color: var(--accent);
    outline: none;
}

.send-btn {
    background: var(--accent);
    color: white;
    border: none;
    width: 42px; height: 42px;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    padding: 0;
    margin: 0;
    flex-shrink: 0;
}

.send-btn:disabled {
    background: #ccc;
    box-shadow: none;
}

/* =======================================
   üì± MOBILE & RESPONSIVE TWEAKS
======================================= */
@media (max-width: 480px) {
  header { padding: 0.6rem 1rem; font-size: 1.1rem; }
  main { padding-bottom: 70px; }
  
  /* Chat nochmals zwingen Fullscreen zu sein falls kleine Screens zicken */
  .mobile-chat-app {
      height: calc(100vh - 50px - 60px) !important; 
  }
}
</style>
</head>
<body data-theme="light">
  <header>
  <span class="app-title">Zeiterfassung</span>
</header>

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  
  <div id="loading-overlay" class="hidden" aria-hidden="true">
    <div class="spinner" role="status" aria-label="Ladevorgang l√§uft"></div>
  </div>

  <main role="main" aria-live="polite">

    <!-- Auth Container -->
    <div id="auth-container" aria-live="polite">
      <section id="login-view" class="view">
        <h2>Login</h2>
        <form id="login-form">
          <input name="email" type="email" required autocomplete="email" placeholder="E-Mail" />
          <input name="passwort" type="password" required autocomplete="current-password" placeholder="Passwort" />
          <button type="submit">Einloggen</button>
        </form>
        <p><a href="#" id="forgot-password-link">Passwort vergessen?</a></p>
        <p id="verifyWarning" class="hidden">
          Deine E-Mail ist noch nicht verifiziert. <br />
          <button id="resendBtn" type="button" disabled>Code erneut senden</button>
        </p>
        <button id="show-register-btn" class="link" type="button">Noch kein Konto?</button>
      </section>

      <section id="reset-request-view" class="view hidden">
        <h2>Passwort zur√ºcksetzen</h2>
        <form id="reset-request-form">
          <input name="email" type="email" required placeholder="E-Mail" />
          <input name="vorname" type="text" required placeholder="Vorname" />
          <input name="nachname" type="text" required placeholder="Nachname" />
          <button type="submit">Code anfordern</button>
        </form>
        <button id="back-to-login-from-request" class="link" type="button">Zur√ºck zum Login</button>
      </section>

      <section id="reset-verify-view" class="view hidden">
        <h2>Code eingeben und neues Passwort setzen</h2>
        <form id="reset-verify-form">
          <input name="email" type="email" required placeholder="E-Mail" />
          <input name="code" type="text" required placeholder="Best√§tigungscode" />
          <input name="neuesPasswort" type="password" required placeholder="Neues Passwort" />
          <button type="submit">Passwort √§ndern</button>
        </form>
        <button id="back-to-login-from-verify" class="link" type="button">Zur√ºck zum Login</button>
      </section>

      <section id="register-view" class="view hidden">
        <h2>Registrieren</h2>
        <form id="register-form">
          <input name="firstname" placeholder="Vorname" required />
          <input name="lastname" placeholder="Nachname" required />
          <input name="email" type="email" placeholder="E-Mail" required />
          <input name="passwort" type="password" placeholder="Passwort" required />
          <button type="submit">Registrieren</button>
        </form>
        <button id="show-login-btn" class="link" type="button">Zur√ºck zum Login</button>
      </section>
    </div>

    <!-- App View -->
    <div id="app-view" class="hidden">
      <nav id="bottom-nav">
        <button data-target="mein-tag-section" aria-label="Mein Tag">
          <i data-lucide="calendar-days"></i>
        </button>
        <button data-target="arbeitsplanung-section" aria-label="Arbeitsplanung">
          <i data-lucide="clipboard-list"></i>
        </button>
        <button data-target="zeiterfassung-section" aria-label="Zeiterfassung" class="main-button">
          <i data-lucide="camera"></i>
        </button>
        <button data-target="chat-section" aria-label="Chat">
          <i data-lucide="message-circle"></i>
        </button>
        <button data-target="settings-section" aria-label="Einstellungen">
          <i data-lucide="settings"></i>
        </button>
      </nav>

      <section id="qr-section" class="card view hidden">
        <h2>QR-Code scannen</h2>
        <div id="qr-reader"></div>
        <p>Bitte scanne deinen QR-Code, um zur Zeiterfassung zu gelangen.</p>
      </section>

      <section id="mein-tag-section" class="card view">
        <h2>Mein Tag</h2>
        <p>Hier siehst du deinen heutigen Einsatz.</p>
        <div class="user-info">Angemeldet als: <span id="user-name">...</span></div>
      </section>

     <section id="arbeitsplanung-section" class="card view hidden">
  <h2>Arbeitsplanung</h2>
  <div id="arbeitsplanung-list">
    <p>(Hier werden die Eins√§tze geladen‚Ä¶)</p>
  </div>
</section>


      <section id="zeiterfassung-section" class="card view hidden">
        <h2>Zeiterfassung</h2>
        <button id="clock-in-btn" type="button">Einstempeln (Start)</button>
        <button id="clock-out-btn" type="button" disabled>Ausstempeln (Stop)</button>
        <p id="time-message"></p>

        <div id="qr-generator-container" class="hidden">
          <h3>QR-Code f√ºr Arbeiter</h3>
          <button id="generate-qr-btn" type="button">QR-Code generieren</button>
          <div id="qr-container"></div>
          <p id="qr-valid-until"></p>
        </div>

        <button id="logout-btn" type="button" style="margin-top:2rem; background:#e74c3c; color:#fff;">
          Ausloggen
        </button>
      </section>

     <section id="chat-section" class="card view hidden mobile-chat-app">
          <section id="chat-list-section" class="chat-sidebar active">
              <header class="chat-sidebar-header">
                  Chats
              </header>
              <ul id="chat-list" class="chat-sidebar-list">
                  <li class="chat-sidebar-item active" data-chat-id="DEFAULT_USER_CHAT_ID">
                      <div class="chat-title">üõ†Ô∏è Admin-Support</div>
                      <div class="chat-preview">Klicken, um Nachricht zu senden...</div>
                  </li>
              </ul>
          </section>

          <section id="chat-main" class="chat-main">
              <header class="chat-header">
                  <button id="back-to-list-btn" class="back-btn">‚Üê</button>
                  <span id="chat-header-title">Admin Chat</span>
              </header>

              <ul id="chat-messages" class="chat-messages">
              </ul>

              <footer class="chat-input-area">
                  <textarea id="chat-input-field" placeholder="Nachricht eingeben..." rows="1"></textarea>
                  <button id="chat-send-btn" class="send-btn">Senden</button>
              </footer>
          </section>
¬† ¬† ¬† </section>

      <section id="settings-section" class="card view hidden">
        <h2>Einstellungen</h2>
        <label for="darkmode-switch-main">
          <input type="checkbox" id="darkmode-switch-main" />
          Dark Mode
        </label>
      </section>
    </div>
  </main>
<!-- QR-Scanner -->
<script src="https://unpkg.com/html5-qrcode"></script>
<!-- QR-Code-Generator Bibliothek -->
<script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>
<!-- Bibiothek f√ºr navbar icons --> 
<script src="https://unpkg.com/lucide@latest"></script>
<script type="module">

//Service worker
// ================== Service Worker Registration ==================
if ('serviceWorker' in navigator) {
  const enableSW = false; // true = SW aktiv, false = Entwicklung

  window.addEventListener('load', () => {
    if (!enableSW) {
      // Alle existierenden Service Worker entfernen
      navigator.serviceWorker.getRegistrations().then(regs => {
        for (let reg of regs) {
          reg.unregister().then(() => console.log("Service Worker deaktiviert:", reg));
        }
      });
      return;
    }

    // Service Worker registrieren
    navigator.serviceWorker.register('/sw.js')
      .then(reg => {
        console.log("Service Worker registriert:", reg);

        // Pr√ºfen auf neue Versionen
        if (reg.waiting) {
          // Update schon installiert, aber noch nicht aktiv ‚Üí Hinweis
          notifySWUpdate(reg.waiting);
        }

        reg.onupdatefound = () => {
          const newWorker = reg.installing;
          console.log("Neuer Service Worker gefunden‚Ä¶");

          newWorker.onstatechange = () => {
            if (newWorker.state === 'installed') {
              if (navigator.serviceWorker.controller) {
                // Neue Version verf√ºgbar
                notifySWUpdate(newWorker);
              } else {
                console.log("Service Worker initial installiert.");
              }
            }
          };
        };
      })
      .catch(err => console.error("SW-Registrierungsfehler:", err));

    // Optional: manuell Update pr√ºfen
    navigator.serviceWorker.ready.then(reg => {
      console.log("Service Worker ready ‚Äì pr√ºfe auf Updates‚Ä¶");
      reg.update();
    });
  });
}

// ================== Hilfsfunktion: Update-Hinweis ==================
function notifySWUpdate(worker) {
  // Einfacher UI-Hinweis (kann angepasst werden)
  const updateBanner = document.createElement('div');
  updateBanner.id = "sw-update-banner";
  updateBanner.style = `
    position: fixed;
    bottom: 10px; left: 50%; transform: translateX(-50%);
    background: #1976d2; color: white; padding: 1rem 2rem;
    border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    font-family: sans-serif; z-index: 9999;
    cursor: pointer;
  `;
  updateBanner.textContent = "Neue Version verf√ºgbar ‚Äì hier klicken, um zu aktualisieren";

  updateBanner.addEventListener('click', () => {
    worker.postMessage({ type: 'SKIP_WAITING' });
    window.location.reload();
  });

  document.body.appendChild(updateBanner);
}
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
  import QRCode from "https://cdn.jsdelivr.net/npm/qrcode@1.5.3/+esm";

 document.addEventListener('DOMContentLoaded', () => {
  const generateBtn = document.getElementById('generate-qr-btn');
  const qrContainer = document.getElementById('qr-container');
  const qrValidUntil = document.getElementById('qr-valid-until');

  if (!generateBtn || !qrContainer || !qrValidUntil) {
    console.warn('‚ö†Ô∏è QR-Code-UI-Element(e) fehlen: Button, Container oder G√ºltigkeitsanzeige nicht gefunden.');
    return;
  }

  generateBtn.addEventListener('click', async () => {
    try {
      const res = await fetch('/api/qr/create', {
        method: 'POST',
        headers: {
          'X-CSRF-Token': csrfToken,
          'Content-Type': 'application/json'
        },
        credentials: 'include'
      });

      if (!res.ok) {
        console.error('‚ùå QR-Code konnte nicht generiert werden ‚Äì Serverfehler:', res.status);
        alert('Fehler beim QR-Code-Generieren');
        return;
      }

      const { qrToken, g√ºltigBis } = await res.json();
      const cleanToken = qrToken.trim();
      console.log('‚ñ∂Ô∏è QR-Inhalt:', cleanToken);

      const canvas = document.createElement('canvas');
      await QRCode.toCanvas(canvas, cleanToken, {
        width: 256,
        margin: 1,
        color: {
          dark: '#000000',
          light: '#ffffff',
        },
        errorCorrectionLevel: 'M'
      });

      qrContainer.innerHTML = '';
      qrContainer.appendChild(canvas);

      const validUntil = new Date(g√ºltigBis).toLocaleTimeString();
      qrValidUntil.textContent = `G√ºltig bis: ${validUntil}`;
    } catch (err) {
      console.error('‚ùå Fehler beim Erzeugen des QR-Codes:', err);
      alert('Fehler beim Abrufen des QR-Codes.');
    }
  });
});

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  //loading screen
function showLoading() {
  document.getElementById('loading-overlay')?.classList.remove('hidden');
}

function hideLoading() {
  document.getElementById('loading-overlay')?.classList.add('hidden');
}
  
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ===================== AUTO REFRESH HANDLING =====================
const sectionIntervals = new Map();

function enableAutoRefresh(sectionId, callback, intervalMs = 60000) {
  const section = document.getElementById(sectionId);
  if (!section) return console.warn(`Section "${sectionId}" nicht gefunden`);

  const observer = new MutationObserver(() => {
    const isVisible = !section.classList.contains("hidden");

    if (isVisible && !sectionIntervals.has(sectionId)) {
      // Start Auto-Refresh
      const container = section.querySelector(`#${sectionId}-list`) || section.querySelector("div");
      if (!container) {
        console.warn(`Container f√ºr Section "${sectionId}" nicht gefunden`);
        return;
      }

      callback(); // sofort laden
      const intervalId = setInterval(callback, intervalMs);
      sectionIntervals.set(sectionId, intervalId);
    } else if (!isVisible && sectionIntervals.has(sectionId)) {
      // Stop Auto-Refresh
      clearInterval(sectionIntervals.get(sectionId));
      sectionIntervals.delete(sectionId);
    }
  });

  observer.observe(section, { attributes: true, attributeFilter: ["class"] });
}

// ===================== ARBEITSPLANUNG =====================
async function loadArbeitsplanung() {
  const list = document.getElementById("arbeitsplanung-list");
  if (!list) return console.warn("arbeitsplanung-list nicht gefunden");

  list.innerHTML = `<p class="loading-text">Lade Eins√§tze...</p>`;

  try {
    const plans = await apiFetch("/api/myworkplans", { method: "GET" });
    console.log("plans", plans);

    if (!plans || plans.length === 0) {
      list.innerHTML = `<p class="empty-text">Keine geplanten Eins√§tze.</p>`;
      return;
    }

    list.innerHTML = "";
    plans.forEach(plan => {
      const card = document.createElement("div");
      card.className = "plan-card theme-card"; // <-- Theme-ready class

      const header = document.createElement("div");
      header.className = "plan-header theme-header";
      header.innerHTML = `
        <span class="plan-location">${plan.location_name || "-"}</span>
        <span class="plan-date">${plan.datum_only || "-"}</span>
        <span class="plan-time">${plan.uhrzeit || "-"}</span>
        <button class="toggle theme-toggle">‚ñº</button>
      `;

      const details = document.createElement("div");
      details.className = "plan-details hidden theme-details";
      details.innerHTML = `
        <p><b>Vorarbeiter:</b> ${plan.vorarbeiter || "-"}</p>
        <p><b>Status:</b> ${statusSymbol(plan.status)} ${plan.status || "-"}</p>
        ${plan.beschreibung ? `<p><b>Beschreibung:</b> ${plan.beschreibung}</p>` : ""}
        ${plan.google_maps_link ? `<a class="theme-link" href="${plan.google_maps_link}" target="_blank">üìç Route anzeigen</a>` : ""}
      `;

      header.querySelector(".toggle").addEventListener("click", () => {
        details.classList.toggle("hidden");
      });

      card.appendChild(header);
      card.appendChild(details);
      list.appendChild(card);
    });
  } catch (err) {
    console.error("Fehler in loadArbeitsplanung:", err);
    list.innerHTML = `<p class="error-text">Fehler beim Laden der Arbeitsplanung: ${err.message || err}</p>`;
  }
}

function statusSymbol(status) {
  switch (status) {
    case "zugesagt": return "üü¢";
    case "abgelehnt": return "üî¥";
    case "wartend": return "‚ö™";
    default: return "‚ö™";
  }
}

// ===================== INIT =====================
document.addEventListener("DOMContentLoaded", () => {
  // Arbeitsplanung alle 60 Sekunden aktualisieren
  enableAutoRefresh("arbeitsplanung-section", loadArbeitsplanung, 60000);

  // Chat (sp√§ter) k√∂nnte so aussehen:
  // enableAutoRefresh("chat-section", loadChatMessages, 5000);
});

///////////////////////////////////////////////////////////////////////////////////////////////////////
//chat
///////////////////////////////////////////////////////////////////////////////////////////////////////
  
// ===================================
// 1. Globale Zustandsvariablen
// ===================================
let activeChat = null; // ‚ö†Ô∏è MUSS durch die tats√§chliche Chat-ID ersetzt werden
let currentUserId = null;           // ID des aktuell eingeloggten Benutzers (f√ºr "user" vs "other")
let lastMessageIds = {};            // Speichert die IDs der bereits geladenen Nachrichten pro Chat
let currentCsrfToken = localStorage.getItem('csrfToken'); // CSRF Token aus LocalStorage laden
let currentAccessToken = null;      // JWT Access Token (vom Refresh/Login)
let reloadIntervalId = null;        // ID des Auto-Reload-Intervalls

  
// ===================================
// 2. Hilfsfunktionen
// ===================================

/**
 * Ruft die prim√§ren Chat-DOM-Elemente ab.
 * @returns {Object|null} Ein Objekt mit den Elementen oder null, wenn die Sektion fehlt.
 */
function getChatElements() {
    const chatSection = document.getElementById('chat-section');
    if (!chatSection) return null;

    return {
        chatSection,
        chatMessages: chatSection.querySelector('.chat-messages'),
        chatHeaderTitle: document.getElementById('chat-header-title'),
        chatInput: document.getElementById('chat-input-field'),
        chatSend: document.getElementById('chat-send-btn'),
        sidebarList: chatSection.querySelector('.chat-sidebar-list')
    };
}

/**
 * Scrollt den Nachrichtencontainer sanft nach unten.
 * @param {HTMLElement} chatMessagesElement - Der Container der Nachrichten.
 */
function scrollToBottom(chatMessagesElement) {
    if (chatMessagesElement) {
        // Leichte Verz√∂gerung f√ºr das Rendern neuer Elemente
        setTimeout(() => {
            chatMessagesElement.scrollTo({ top: chatMessagesElement.scrollHeight, behavior: 'smooth' });
        }, 50); 
    }
}

/**
 * Erstellt und f√ºgt eine Nachricht in den Chat ein (mit Duplikat- und Optimistic-Update-Logik).
 * @param {string} content - Nachrichtentext (kann HTML enthalten).
 * @param {'user'|'other'} sender - Absender-Typ.
 * @param {HTMLElement} chatMessagesElement - Das UL-Element der Nachrichten.
 * @param {string | null} msgId - Echte Server-ID (wenn geladen).
 * @param {string | null} tempId - Tempor√§re Client-ID (f√ºr gesendete, aber unbest√§tigte Nachrichten).
 */
function addMessage(content, sender = 'user', chatMessagesElement, msgId = null, tempId = null) {
    if (!chatMessagesElement) return;

    // Duplikat-Check f√ºr Server-Nachrichten
    if (msgId && chatMessagesElement.querySelector(`.message[data-id="${msgId}"]`)) return;

    // Ersetze alte tempor√§re Nachricht, falls Server-ID und Temp-ID √ºbereinstimmen
    if(msgId && tempId) {
        const tempMsg = chatMessagesElement.querySelector(`.message[data-temp-id="${tempId}"]`);
        if(tempMsg) chatMessagesElement.removeChild(tempMsg);
    }

    const li = document.createElement('li');
    li.classList.add('message', sender);
    if (msgId) li.dataset.id = msgId;
    if (tempId) li.dataset.tempId = tempId;

    const divContent = document.createElement('div');
    divContent.classList.add('message-content');
    divContent.innerHTML = `<p>${content}</p>`;

    li.appendChild(divContent);

    // Optisches Feedback f√ºr gesendete, aber noch nicht best√§tigte Nachrichten
    if (!msgId) {
        li.dataset.status = 'sending';
        li.style.opacity = '0.6';
    }

    chatMessagesElement.appendChild(li);
    scrollToBottom(chatMessagesElement);
}

// ===================================
// 3. CSRF-Token & User-ID sicherstellen
// ===================================

/**
 * Pr√ºft vorhandene Tokens oder f√ºhrt einen Refresh-Call durch, um neue zu erhalten.
 * Wenn der Refresh fehlschl√§gt, wird ein Fehler geworfen (f√ºhrt zur Abmeldung).
 * @returns {Promise<{csrfToken: string, accessToken: string, userId: string}>} Die aktuellen Tokens und User ID.
 */
async function ensureCsrfToken() {
    // 1. Sofortige R√ºckgabe, wenn Tokens und User ID bereits im State sind
    if (currentCsrfToken && currentAccessToken && currentUserId) 
        return { csrfToken: currentCsrfToken, accessToken: currentAccessToken, userId: currentUserId };

    try {
        // 2. Refresh √ºber API (nutzt Refresh-Cookie)
        const res = await fetch(`/api/refresh`, {
            method: 'POST',
            credentials: 'include' // WICHTIG: Sendet den Refresh-Cookie mit
        });

        if (!res.ok) {
            localStorage.removeItem('csrfToken');
            currentCsrfToken = null;
            throw new Error(`Session abgelaufen (${res.status}). Bitte neu anmelden.`);
        }

        const data = await res.json();
        
        // 3. Speichern und Zur√ºckgeben der neuen Tokens/Daten
        // üö® WICHTIG: Das Backend MUSS csrfToken, accessToken und userId im JSON-Body zur√ºckgeben!
        if (data.csrfToken && data.accessToken && data.userId) { 
            currentCsrfToken = data.csrfToken;
            currentAccessToken = data.accessToken;
            currentUserId = data.userId;
            localStorage.setItem('csrfToken', data.csrfToken);
            
            return { csrfToken: currentCsrfToken, accessToken: currentAccessToken, userId: currentUserId };
        }
        
        throw new Error('Kein CSRF/Access Token oder User ID im Refresh erhalten');

    } catch (err) {
        console.error("Auth-Fehler beim Refresh:", err);
        localStorage.removeItem('csrfToken');
        currentCsrfToken = null;
        throw err;
    }
}

// ===================================
// 4.1 Nachrichten laden (mit ID-Pr√ºfung)
// ===================================

async function fetchChatMessages(chatId) {
    const elems = getChatElements();
    if (!elems) return;

    const { chatMessages } = elems;
    const endpoint = `/api/chat/${chatId}`;

    // WICHTIG: Pr√ºfen, ob dieser Chat noch aktiv ist, bevor wir rendern
    if (chatId !== activeChat) {
        console.warn('Chat-Nachrichten ignoriert, da nicht mehr aktiv.');
        return;
    }

    try {
        const tokens = await ensureCsrfToken(); // Tokens sicherstellen
        
        const res = await fetch(endpoint, {
            headers: { 'Authorization': `Bearer ${tokens.accessToken}` },
            credentials: 'include'
        });
        
        if (!res.ok) throw new Error(`Fehler beim Laden (${res.status})`);

        const data = await res.json();
        const userId = tokens.userId;
        let newMessagesAdded = false;

        if (!lastMessageIds[chatId]) lastMessageIds[chatId] = new Set();
        
        data.forEach(msg => {
            // Duplikat √ºberspringen
            if (lastMessageIds[chatId].has(msg.id)) return;
            lastMessageIds[chatId].add(msg.id);
            
            // Absender-Klasse bestimmen
        const senderClass = msg.sender_id === userId ? 'user' : 'other';
        
        // ‚ö†Ô∏è Angepasster Nachrichteninhalt: Name und Rolle anzeigen
        const content = msg.sender_id !== userId
            ? `<strong>${msg.sender_name || 'System'}</strong> (${msg.sender_rolle || 'Arbeiter'}): ${msg.text}`
            : msg.text;
        
        addMessage(content, senderClass, chatMessages, msg.id);
        newMessagesAdded = true;
});
        
        if(newMessagesAdded) {
            scrollToBottom(chatMessages);
        }

    } catch (err) {
        console.error('Fehler beim Laden der Chatnachrichten:', err);
        if(chatMessages && chatMessages.children.length === 0) {
            chatMessages.innerHTML = '<li style="color:red; list-style:none;">Verbindungsfehler oder keine Nachrichten.</li>';
        }
    }
}

//L√§dt Admin-Kontakte und injiziert sie in die Sidebar.
async function loadChatSidebar() {
    const elems = getChatElements();
    if (!elems || !elems.sidebarList) return;
    
    elems.sidebarList.innerHTML = '<li class="loading-item">Lade Kontakte...</li>';

    try {
        const tokens = await ensureCsrfToken();
        
        // 1. Kontakte vom Backend laden
        const res = await fetch(`/api/chat/contacts`, {
            headers: { 'Authorization': `Bearer ${tokens.accessToken}` },
            credentials: 'include'
        });
        
        if (!res.ok) throw new Error('Fehler beim Laden der Kontakte');

        const contacts = await res.json();
        elems.sidebarList.innerHTML = '';
        
        if (contacts.length === 0) {
            elems.sidebarList.innerHTML = '<li class="info-item">Keine Admin-Kontakte gefunden.</li>';
            return;
        }

        // 2. Kontakte in die Sidebar rendern
        contacts.forEach(user => {
            const li = document.createElement('li');
            li.classList.add('chat-sidebar-item');
            li.dataset.userId = user.id;
            li.innerHTML = `
                <div class="contact-name">${user.vorname} ${user.nachname}</div>
                <div class="contact-role">(${user.rolle})</div>
            `;
            
            // 3. Event Listener f√ºr Chat-Initialisierung hinzuf√ºgen
            li.addEventListener('click', () => {
                initiateChat(user.id, `${user.vorname} (${user.rolle})`);
            });

            elems.sidebarList.appendChild(li);
        });

    } catch (error) {
        console.error('Fehler beim Laden der Sidebar:', error);
        elems.sidebarList.innerHTML = '<li class="error-item">Fehler beim Laden der Kontakte.</li>';
    }
}

/**
 * Ruft die Chat ID f√ºr das 1:1 Paar ab oder erstellt sie und aktiviert dann den Chat.
 * @param {number} targetUserId - Die ID des Gespr√§chspartners.
 * @param {string} chatName - Der anzuzeigende Name.
 */
async function initiateChat(targetUserId, chatName) {
    showLoading(); // Ladeanzeige starten

    // Den Zustand des aktuell aktiven Chats zur√ºcksetzen, falls einer offen war
    deactivateChat(); 

    try {
        const tokens = await ensureCsrfToken();
        
        const res = await fetch(`/api/chat/init/${targetUserId}`, {
            method: 'POST',
            headers: { 
                'Authorization': `Bearer ${tokens.accessToken}`,
                'Content-Type': 'application/json',
                'X-CSRF-Token': tokens.csrfToken // CSRF-Token senden
            },
            credentials: 'include'
        });
        
        if (!res.ok) throw new Error('Chat-Initialisierung fehlgeschlagen.');

        const data = await res.json();
        
        if (data.chatId) {
            // UI-Wechsel (Muss zu Ihrer Haupt-App-Logik passen)
            document.getElementById('chat-list-section').classList.remove('active'); // Wenn Sie eine Listenansicht haben
            document.getElementById('chat-main').classList.add('active'); // Wenn Sie eine Chat-Ansicht haben
            
            // 4. Chat aktivieren mit der echten ID
            activateChat(data.chatId, chatName);
        } else {
            throw new Error('Keine Chat ID erhalten.');
        }

    } catch (error) {
        console.error('Fehler beim Starten des Chats:', error);
        alert('Der Chat konnte nicht gestartet werden: ' + error.message);
    } finally {
        hideLoading(); // Ladeanzeige beenden
    }
}
  
// ===================================
// 4.2 Nachricht senden (mit Optimistic Update)
// ===================================

async function handleSendClick() {
    const elems = getChatElements();
    if (!elems || !activeChat) return;

    const { chatInput, chatMessages, chatSend } = elems;
    const message = chatInput.value.trim();
    if (!message) return;

    chatSend.disabled = true;
    
    // Tempor√§re ID f√ºr das Optimistic Update
    const tempId = Date.now().toString();  
    
    // 1. Optimistic Update: Nachricht sofort anzeigen
    addMessage(message, 'user', chatMessages, null, tempId);  
    chatInput.value = '';
    chatInput.focus();
    
    try {
        const tokens = await ensureCsrfToken();  
        
        const res = await fetch(`/api/chat/${activeChat}`, {
            method: 'POST',
            headers: {  
                'Content-Type': 'application/json',  
                'X-CSRF-Token': tokens.csrfToken,  
                'Authorization': `Bearer ${tokens.accessToken}`  
            },
            credentials: 'include',
            body: JSON.stringify({ message })
        });
        
        if (!res.ok) throw new Error(`Sende-Fehler (${res.status})`);

        // 2. Erfolg: Lade die neueste Nachricht vom Server (best√§tigt die gesendete Nachricht)
        await fetchChatMessages(activeChat);  

        // 3. Sicherheits-Cleanup: Falls das Duplikat nicht durch fetchChatMessages entfernt wurde
        const tempMsg = chatMessages.querySelector(`.message[data-temp-id="${tempId}"]`);
        if(tempMsg) chatMessages.removeChild(tempMsg);

    } catch (error) {
        console.error('Netzwerkfehler beim Senden:', error);
        
        // 4. Fehler: Tempor√§re Nachricht als Fehler markieren
        const tempMsg = chatMessages.querySelector(`.message[data-temp-id="${tempId}"]`);
        if(tempMsg) {
            tempMsg.dataset.status = 'failed';
            tempMsg.style.backgroundColor = '#fdd';  
            tempMsg.querySelector('.message-content').innerHTML += '<span style="color:red; display:block; font-size: 0.75rem;"> [FEHLER] </span>';
        }
    } finally {
        chatSend.disabled = false;
        chatInput.style.height = 'auto';  
    }
}

// ===================================
// 5. Chat wechseln / aktivieren
// ===================================

/**
 * Setzt den aktuellen Chat, leert die UI und startet den Auto-Reload.
 * @param {string} chatId - Die ID des zu aktivierenden Chats.
 */
function activateChat(chatId, chatName) {
    const elems = getChatElements();
    if (!elems) return;
    const { chatHeaderTitle, chatInput, chatSend, chatMessages } = elems;

    // UI-Vorbereitung
    if(chatHeaderTitle) chatHeaderTitle.textContent = chatName || 'Admin Chat'; // Verwende den √ºbergebenen Namen
    if(chatMessages) chatMessages.innerHTML = '';  // WICHTIG: UI leeren, um alten Inhalt zu entfernen
    if (chatInput && chatSend) {
        chatInput.disabled = false;
        chatSend.disabled = false;
        chatInput.placeholder = `Nachricht an ${chatName}...`;
    }

    // Altes Intervall stoppen, um Duplikate zu verhindern (sollte durch deactivateChat bereits geschehen sein, aber zur Sicherheit)
    if (reloadIntervalId) {
        clearInterval(reloadIntervalId);
    }
    
    activeChat = chatId;
    
    // Initiales Laden
    fetchChatMessages(chatId);
    
    // Neues Auto-Reload Intervall starten
    reloadIntervalId = setInterval(() => {
        fetchChatMessages(activeChat);
    }, 10000); // Alle 10 Sekunden
}

// ===================================
// 6. Chat deaktivieren / Zustand zur√ºcksetzen
// ===================================

/**
 * Setzt den Chat-Zustand zur√ºck (Intervall stoppen, IDs l√∂schen).
 */
function deactivateChat() {
    if (reloadIntervalId) {
        clearInterval(reloadIntervalId);
        reloadIntervalId = null;
    }
    
    // WICHTIG: Den Cache f√ºr den aktiven Chat leeren, damit beim erneuten √ñffnen alles neu geladen wird.
    if (activeChat && lastMessageIds[activeChat]) {
        delete lastMessageIds[activeChat];
    }

    activeChat = null;
    const elems = getChatElements();
    if (elems && elems.chatMessages) {
        elems.chatMessages.innerHTML = '';
    }
}


// ===================================
// 7. DOM Ready & Event Listeners
// ===================================

document.addEventListener('DOMContentLoaded', async () => {
    const elems = getChatElements();
    if (!elems) return;
    const { chatInput, chatSend } = elems;
    
    // Die initialChatId sollte aus einem Data-Attribut im HTML kommen,
    // oder die Standard-ID verwenden, falls keine Sidebar vorhanden ist.
    const initialChatId = document.querySelector('.chat-sidebar-item[data-chat-id]')?.dataset.chatId || activeChat;

    // --- A. Sitzung Wiederherstellen ---
    // Versuche, Tokens zu aktualisieren, falls der Benutzer eingeloggt war (LocalStorage vorhanden).
    if (localStorage.getItem('csrfToken')) {
        try {
            // Ruft ensureCsrfToken auf, um die Session zu validieren
            const tokens = await ensureCsrfToken();  
            
            // Wenn der Token-Check erfolgreich ist: 
            // Hier m√ºssten Sie das App-UI anzeigen (z.B. document.getElementById('app-view').classList.remove('hidden');)
            
            // Automatische Aktivierung des Chats, wenn eine g√ºltige ID vorliegt (optional)
            if (initialChatId && initialChatId !== activeChat) {
                    // activateChat(initialChatId);  
                    // WICHTIG: Die activateChat Logik sollte hier wahrscheinlich nicht automatisch laufen,
                    // sondern nur, wenn der Benutzer auf das Chat-Element klickt.
            }
            
        } catch (error) {
            console.error("Session abgelaufen. Bitte neu anmelden.", error);
            // Weiterleitung zur Login-Seite oder Anzeige des Login-Containers
        }
    }


    // --- B. Event Listener binden ---

    // 1. Senden-Button
    if (chatSend) {  
        chatSend.addEventListener('click', handleSendClick);  
    }
    
    // 2. Chat-Input: Enter & Auto-Resize
    if (chatInput) {
        chatInput.addEventListener('keydown', e => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                if (chatSend && !chatSend.disabled) handleSendClick();
            }
        });

        chatInput.addEventListener('input', () => {
            chatInput.style.height = 'auto';  
            chatInput.style.height = chatInput.scrollHeight + 'px';
        });
    }

    // 3. Sidebar Klick (Beispiel)
    const chatSidebarItem = document.querySelector('.chat-sidebar-item[data-chat-id]');
    if(chatSidebarItem) {
        chatSidebarItem.addEventListener('click', () => {
              const targetChatId = chatSidebarItem.dataset.chatId;
              // UI-Wechsel (Muss zu Ihrer Haupt-App-Logik passen)
              document.getElementById('chat-list-section').classList.remove('active');
              document.getElementById('chat-main').classList.add('active');
              activateChat(targetChatId);  
        });
    }

    // 4. Zur√ºck-Button (FIX: F√ºgt deactivateChat hinzu)
    const backBtn = document.getElementById('back-to-list-btn');
    if(backBtn) {
        backBtn.addEventListener('click', () => {
              // üö® WICHTIG: Zustand zur√ºcksetzen, um Neuladen zu erzwingen
              deactivateChat(); 
              document.getElementById('chat-main').classList.remove('active');
              document.getElementById('chat-list-section').classList.add('active');
        });
    }
});

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
document.addEventListener('DOMContentLoaded', () => {
  const darkmodeSwitch = document.getElementById('darkmode-switch-main');
  if (!darkmodeSwitch) {
    console.warn('‚ö†Ô∏è Darkmode-Switch #darkmode-switch-main nicht gefunden.');
    return;
  }

  function setTheme(theme) {
    document.documentElement.setAttribute('data-theme', theme);
    localStorage.setItem('theme', theme);
    darkmodeSwitch.checked = theme === 'dark';
  }

  // Gespeicherten Wert oder Systemvoreinstellung laden
  const savedTheme = localStorage.getItem('theme');
  if (savedTheme) {
    setTheme(savedTheme);
  } else {
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    setTheme(prefersDark ? 'dark' : 'light');
  }

  // Umschalten
  darkmodeSwitch.addEventListener('change', () => {
    setTheme(darkmodeSwitch.checked ? 'dark' : 'light');
  });
});

// Zeitstatus pr√ºfen
document.addEventListener('DOMContentLoaded', async () => {
  const token = sessionStorage.getItem('accessToken');
  if (!token) {
    console.warn('‚õî Kein accessToken in sessionStorage ‚Äì Statuspr√ºfung √ºbersprungen.');
    return;
  }

  try {
    const status = await getLetzterStatus();

    const clockInBtn = document.getElementById('clock-in-btn');
    const clockOutBtn = document.getElementById('clock-out-btn');

    if (!clockInBtn || !clockOutBtn) {
      console.warn('‚ö†Ô∏è Clock-In oder Clock-Out Button nicht im DOM gefunden.');
      return;
    }

    const eingestempelt = status?.eingestempelt;

    if (eingestempelt === true) {
      clockInBtn.disabled = true;
      clockOutBtn.disabled = false;
    } else if (eingestempelt === false) {
      clockInBtn.disabled = false;
      clockOutBtn.disabled = true;
    } else {
      console.warn('‚ö†Ô∏è Ung√ºltiger Statuswert:', eingestempelt);
      clockInBtn.disabled = false;
      clockOutBtn.disabled = false;
    }
  } catch (err) {
    console.error('‚ùå Fehler beim Abrufen des letzten Zeitstatus:', err);
  }
});

lucide.createIcons();
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Alles zum passwort zur√ºcksetzen
  
const authContainer = document.getElementById('auth-container');

const views = {
  login: document.getElementById('login-view'),
  resetRequest: document.getElementById('reset-request-view'),
  resetVerify: document.getElementById('reset-verify-view'),
};

function showView(viewName) {
  Object.values(views).forEach(view => view.classList.add('hidden'));
  views[viewName].classList.remove('hidden');
}

// Login ‚Üí Passwort vergessen Link √∂ffnet resetRequest
document.getElementById('forgot-password-link').addEventListener('click', e => {
  e.preventDefault();
  // Login-E-Mail im Reset-Form vorausf√ºllen (optional)
  const loginEmail = views.login.querySelector('input[name="email"]').value;
  views.resetRequest.querySelector('input[name="email"]').value = loginEmail || '';
  showView('resetRequest');
});

// Zur√ºck-Buttons
document.getElementById('back-to-login-from-request').addEventListener('click', () => showView('login'));
document.getElementById('back-to-login-from-verify').addEventListener('click', () => showView('login'));

// Hilfsfunktion zur Passwortvalidierung
function isValidPassword(pwd) {
  return (
    typeof pwd === 'string' &&
    pwd.length >= 8 &&
    /[A-Z]/.test(pwd) &&
    /[0-9]/.test(pwd) &&
    /[!@#$%^&*(),.?":{}|<>_\-\\\/\[\];'`~+=]/.test(pwd)
  );
}

// Optional: Fehlermeldung unter Passwortfeld anzeigen / entfernen
function showPasswordError(input, message) {
  let errorEl = input.nextElementSibling;
  if (!errorEl || !errorEl.classList.contains('password-error')) {
    errorEl = document.createElement('div');
    errorEl.className = 'password-error';
    errorEl.style.color = 'red';
    errorEl.style.fontSize = '0.9rem';
    errorEl.style.marginTop = '0.3rem';
    input.parentNode.insertBefore(errorEl, input.nextSibling);
  }
  errorEl.textContent = message;
}

// Live-Validierung f√ºr Passwort im Reset-Verify-Form
const resetPasswordInput = views.resetVerify.querySelector('input[name="neuesPasswort"]');
if (resetPasswordInput) {
  resetPasswordInput.setAttribute('autocomplete', 'new-password');
  resetPasswordInput.addEventListener('input', () => {
    if (resetPasswordInput.value === '') {
      showPasswordError(resetPasswordInput, '');
    } else if (!isValidPassword(resetPasswordInput.value)) {
      showPasswordError(
        resetPasswordInput,
        'Passwort muss mindestens 8 Zeichen, 1 Gro√übuchstabe, 1 Zahl & 1 Sonderzeichen enthalten.'
      );
    } else {
      showPasswordError(resetPasswordInput, '');
    }
  });
}

// Passwort zur√ºcksetzen - Schritt 1: Code anfordern
document.getElementById('reset-request-form').addEventListener('submit', async e => {
  e.preventDefault();
  const form = e.target;
  const data = {
    email: form.email.value.trim(),
    vorname: form.vorname.value.trim(),
    nachname: form.nachname.value.trim(),
  };

  try {
    const res = await fetch('/api/reset-request', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    });
    const json = await res.json();

    if (!res.ok) throw new Error(json.error || 'Fehler beim Anfordern des Codes');

    // Email auch im Verifizierungsformular vorausf√ºllen
    views.resetVerify.querySelector('input[name="email"]').value = data.email;

    alert('Code wurde verschickt. Bitte √ºberpr√ºfe deine E-Mails.');
    showView('resetVerify');
  } catch (err) {
    alert(err.message);
  }
});

// Passwort zur√ºcksetzen - Schritt 2: Code pr√ºfen + Passwort √§ndern
document.getElementById('reset-verify-form').addEventListener('submit', async e => {
  e.preventDefault();
  const form = e.target;

  const neuesPasswort = form.neuesPasswort.value.trim();

  // Passwort validieren vor dem Absenden
  if (!isValidPassword(neuesPasswort)) {
    alert('Passwort muss mindestens 8 Zeichen lang sein und mindestens einen Gro√übuchstaben, eine Zahl und ein Sonderzeichen enthalten.');
    form.neuesPasswort.focus();
    return;
  }

  const verifyData = {
    email: form.email.value.trim(),
    code: form.code.value.trim(),
  };

  try {
    // Code validieren + resetToken erhalten
    let res = await fetch('/api/reset-verify', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(verifyData),
    });
    let json = await res.json();

    if (!res.ok) throw new Error(json.error || 'Code ung√ºltig');

    const resetToken = json.resetToken;

    // Neues Passwort setzen
    res = await fetch('/api/reset-password', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        resetToken,
        neuesPasswort,
      }),
    });
    json = await res.json();

    if (!res.ok) throw new Error(json.error || 'Fehler beim Passwort setzen');

    alert('Passwort erfolgreich ge√§ndert. Bitte logge dich neu ein.');
    showView('login');
  } catch (err) {
    alert(err.message);
  }
});
  
// API-Konstanten
const BASE = '/api';
const API_BASE = '/api';
const API_BASE_URL = '';
  
// DOM-Elemente
const loginForm = document.getElementById('login-form');
const registerForm = document.getElementById('register-form');
const showRegisterBtn = document.getElementById('show-register-btn');
const showLoginBtn = document.getElementById('show-login-btn');
const logoutBtn = document.getElementById('logout-btn');
const userNameSpan = document.getElementById('user-name');
const clockInBtn = document.getElementById('clock-in-btn');
const clockOutBtn = document.getElementById('clock-out-btn');
const qrSection = document.getElementById('qr-section');
const navButtons = Array.from(document.querySelectorAll('#bottom-nav button'));
const zeiterfassungSection = document.getElementById("zeiterfassung-section");
const meinTagSection = document.getElementById("mein-tag-section");
const arbeitsplanungSection = document.getElementById("arbeitsplanung-section");
const chatSection = document.getElementById("chat-section");
const settingsSection = document.getElementById("settings-section");
const verifyWarning = document.getElementById('verifyWarning');
const resendBtn = document.getElementById('resendBtn');

// Navbar Button (gro√üer Zeiterfassungsbutton)
const zeiterfassungBtn = document.querySelector('button.main-button[data-target="zeiterfassung-section"]');

// Settings (Dropdown oben rechts)
const darkModeSwitch = document.getElementById('darkmode-switch-main');

// Bereiche / Views
const qrGeneratorSection = document.getElementById('qr-generator-container'); // QR-Code Generator
const loginSection = document.getElementById('login-view');
const registerSection = document.getElementById('register-view');

const qrReaderElem = document.getElementById('qr-reader');
const qrMessage = document.getElementById('qr-message');

const loginEmail = document.getElementById('login-email');
const loginPassword = document.getElementById('login-password');
const loginError = document.getElementById('login-error');

// Session-Zustand
let csrfToken = localStorage.getItem('csrfToken') || '';
let loggedInUser = null;

// Globale Rolle merken (wird beim Login gesetzt)
let isVorarbeiterGlobal = false; 

// Statusvariablen
let scannerIsRunning = false;
let html5QrCode = null;
let qrScanErfolgt = false;
  
// Hilfsfunktion: Cookie auslesen
function getCookie(name) {
  const cookies = document.cookie.split(';').map(c => c.trim());
  for (const cookie of cookies) {
    if (cookie.startsWith(name + '=')) {
      return decodeURIComponent(cookie.substring(name.length + 1));
    }
  }
  return null;
}

  // QR-Code validieren (API-Aufruf)
  async function validateQrCode(qr) {
    const csrfToken = localStorage.getItem("csrfToken");
    const res = await fetch(`${API_BASE}/validate-qr`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-CSRF-Token": csrfToken,
      },
      credentials: "include",
      body: JSON.stringify({ qr }),
    });
    if (!res.ok) {
      const err = await res.json().catch(() => ({}));
      throw new Error(err.error || "Ung√ºltiger QR-Code");
    }
    return await res.json();
  }

  // QR-Code wurde erkannt und validiert
  async function onQrCodeDetected(decodedText) {
    try {
      console.log("‚û°Ô∏è QR-Code erkannt:", decodedText);
      await validateQrCode(decodedText);
      console.log("‚úÖ QR-Code g√ºltig ‚Äì Zeiterfassung wird ge√∂ffnet.");
      qrScanErfolgt = true;
      await hideQrGate();
      showSection(zeiterfassungSection);
    } catch (err) {
      console.warn("‚õî QR ung√ºltig:", err.message);
      alert("Ung√ºltiger QR-Code: " + err.message);
      await startQrScanner();
    }
  }
  
// QR-Gate anzeigen und Scanner starten
async function showQrGate() {
  if (isVorarbeiterGlobal) return; // Schutzregel
  if (!qrSection) return;
  qrSection.classList.remove("hidden");
  qrSection.setAttribute("aria-hidden", "false");
  await startQrScanner();
}

// QR-Gate verstecken und Scanner stoppen
async function hideQrGate() {
    if (!qrSection) return;
    qrSection.classList.add("hidden");
    qrSection.setAttribute("aria-hidden", "true");
    await stopQrScanner();
  }

 // QR Scanner starten
 async function startQrScanner() {
  if (html5QrCode) {
    console.log("üì∑ Scanner l√§uft schon, Start √ºbersprungen");
    return;
  }

  if (isVorarbeiterGlobal) {
    console.log("üë∑ Vorarbeiter - QR-Scanner wird nicht gestartet.");
    qrScanErfolgt = true; // Gate √ºberspringen
    return;
  }

  const qrReaderElement = document.getElementById('qr-reader');
  if (!qrReaderElement) {
    console.error("‚ùå #qr-reader nicht gefunden!");
    return;
  }

  html5QrCode = new Html5Qrcode("qr-reader");

  try {
    await html5QrCode.start(
      { facingMode: "environment" },
      {
        fps: 10,
        qrbox: { width: 250, height: 250 },
        aspectRatio: 1.333,
      },
      async (decodedText, decodedResult) => {
        if (qrScanErfolgt) return;
        qrScanErfolgt = true;

        console.log("‚úÖ QR-Code erkannt:", decodedText);

        await onQrCodeDetected(decodedText);

        await stopQrScanner();
      },
      (errorMessage) => {
        // Fehler ignorieren, wenn keine Codes gefunden
      }
    );
  } catch (err) {
    console.error("Fehler beim Starten des QR-Scanners:", err);
  }
}

  // QR Scanner stoppen
  async function stopQrScanner() {
    if (html5QrCode) {
      try {
        await html5QrCode.stop();
        html5QrCode.clear();
      } catch (err) {
        console.error("‚ùå Fehler beim Stoppen des Scanners:", err);
      } finally {
        html5QrCode = null;
      }
    }
    qrScanErfolgt = false;
  }
  
// Haupt-Fetch mit automatischem Token-Refresh, CSRF-Token und Auth-Header
async function apiFetch(path, options = {}) {
    const method = (options.method || 'GET').toUpperCase();
    const writeMethods = ['POST', 'PUT', 'DELETE', 'PATCH'];

    options = { ...options };
    options.headers = options.headers || {};
    options.credentials = 'include'; // wichtig f√ºr Cookies

    // CSRF-Header bei schreibenden Requests
    if (writeMethods.includes(method)) {
        if (!options.headers['Content-Type']) {
            options.headers['Content-Type'] = 'application/json';
        }

        if (csrfToken) {
            options.headers['X-CSRF-Token'] = csrfToken;
        } else {
            console.warn('‚ö†Ô∏è Kein CSRF-Token vorhanden.');
        }
    }

    const url = path.startsWith('http') ? path : (API_BASE_URL + path);

    const fetchWithCookies = () => fetch(url, options);

    let response = await fetchWithCookies();

    // Falls AccessToken abgelaufen ‚Üí versuche Refresh
    if (response.status === 401) {
        const refreshRes = await fetch(`${API_BASE_URL}/api/refresh`, {
            method: 'POST',
            credentials: 'include',
        });

        if (!refreshRes.ok) {
            throw new Error('Login abgelaufen. Bitte neu einloggen.');
        }

        // Neuen CSRF-Token √ºbernehmen (optional)
        const data = await refreshRes.json().catch(() => null);
        if (data?.csrfToken) {
            csrfToken = data.csrfToken;
            localStorage.setItem('csrfToken', csrfToken);
        }

        // Wiederhole urspr√ºnglichen Request
        response = await fetchWithCookies();

        if (response.status === 401) {
            throw new Error('Token-Refresh gescheitert. Bitte neu einloggen.');
        }
    }

    if (!response.ok) {
        let code = 'HTTP_ERROR';
        let message = `Fehler: HTTP ${response.status}`;
        try {
            const err = await response.json();
            code = err?.code || code;
            message = err?.error || err?.message || message;
        } catch {}

        throw { code, message };
    }

    try {
        return await response.json();
    } catch {
        return {};
    }
}
  
// Login-Funktion: speichert Access- und CSRF-Token
async function login(email, passwort) {
    if (!email || !passwort) {
        throw { code: 'MISSING_FIELDS', message: 'Bitte Email und Passwort ausf√ºllen!' };
    }

    try {
        const res = await apiFetch('/api/login', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email, passwort }),
        });

        if (!res.user) {
            throw { code: 'NO_USER', message: 'Login erfolgreich, aber kein Benutzerobjekt erhalten.' };
        }

        console.log('‚úÖ Eingeloggt:', res.user);

        if (res.csrfToken) {
            localStorage.setItem('csrfToken', res.csrfToken);
            csrfToken = res.csrfToken;
        }

        loggedInUser = res.user;

        // üí° KORREKTUR: ADMIN hat dieselben Rechte wie Vorarbeiter
        isVorarbeiterGlobal = res.user.rolle === 'vorarbeiter' || res.user.rolle === 'admin';
        if (isVorarbeiterGlobal) {
            console.log('Vorarbeiter/Admin eingeloggt ‚Üí QR-Skip/Admin-Funktionen aktiv');
        }

        await updateUIAfterLogin(res.user);
        
        // üÜï NEU: Chat-Sidebar nach erfolgreichem Login laden
        await loadChatSidebar(currentUserId);

    } catch (err) {
        if (err?.code === 'EMAIL_NOT_VERIFIED') {
            throw err; // gezielt weiterreichen
        }

        const message = err?.message || 'Unbekannter Fehler beim Login.';
        throw { code: 'LOGIN_FAILED', message };
    }
}
  
loginForm.addEventListener('submit', async (event) => {
  event.preventDefault();

  const email = loginForm.email.value.trim();
  const passwort = loginForm.passwort.value;

  verifyWarning.classList.add('hidden');
  resendBtn.disabled = true;
  resendBtn.dataset.email = '';

  showLoading(); // ‚¨ÖÔ∏è Ladeanzeige starten

  try {
    await login(email, passwort);
  } catch (err) {
    console.error('Login fehlgeschlagen:', err);

    if (err.code === 'LOGIN_FAILED' && err.message.includes('E-Mail')) {
      verifyWarning.classList.remove('hidden');
      resendBtn.disabled = false;
      resendBtn.dataset.email = email;
    } else {
      alert(err.message || 'Unbekannter Fehler beim Login.');
    }
  } finally {
    hideLoading(); // ‚¨ÖÔ∏è Ladeanzeige immer beenden (auch bei Fehlern)
  }
});

// Klick auf "Code erneut senden"
resendBtn.addEventListener('click', async () => {
  const email = resendBtn.dataset.email;
  if (!email) return;

  resendBtn.disabled = true;
  resendBtn.textContent = 'Sende...';

  try {
    const res = await apiFetch('/api/resend-verification', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email }),
    });

    if (res.success) {
      resendBtn.textContent = 'Code gesendet!';
      setTimeout(() => {
        resendBtn.textContent = 'Code erneut senden';
        resendBtn.disabled = false;
      }, 15000); // 15 Sekunden Sperre
    } else {
      alert(res.message || 'Fehler beim Senden');
      resendBtn.disabled = false;
      resendBtn.textContent = 'Code erneut senden';
    }
  } catch (err) {
    console.error('Fehler beim erneuten Senden:', err);
    alert('Netzwerkfehler beim Senden.');
    resendBtn.disabled = false;
    resendBtn.textContent = 'Code erneut senden';
  }
});
  
async function updateProfile() {
    try {
        const user = await apiFetch('/api/me', {}, true); // optional: mit Authorization
        loggedInUser = user;
        
        updateUIAfterLogin(user); // ‚¨ÖÔ∏è hier √úbergabe fixen!
    } catch (err) {
        console.error('Profil konnte nicht geladen werden:', err);
        handleLogoutCleanup();
    }
}
  
// === Sections anzeigen ===
function showSection(section) {
    if (!section) {
        console.error("‚ùå showSection: √úbergabe-Section ist null oder undefiniert!");
        return;
    }

    // Falls String √ºbergeben wurde ‚Üí DOM-Element holen
    if (typeof section === 'string') {
        const el = document.getElementById(section);
        if (!el) {
            console.error("‚ùå showSection: Kein Element gefunden mit ID:", section);
            return;
        }
        section = el;
    }

    // Alle ".view"-Sektionen im #app-view ausblenden
    const appView = document.getElementById('app-view');
    if (appView) {
        appView.querySelectorAll('.view').forEach(sec => {
            sec.classList.add('hidden');
            sec.setAttribute('aria-hidden', 'true');
        });
    }

    // Gew√ºnschte Section anzeigen
    section.classList.remove('hidden');
    section.setAttribute('aria-hidden', 'false');
}

function showPopupMessage(msg, duration = 3000) {
    const popup = document.getElementById('popup-message');
    popup.textContent = msg;
    popup.classList.remove('hidden');

    setTimeout(() => {
        popup.classList.add('hidden');
    }, duration);
}
  
// === Helper Funktionen zur Base64-URL-Konvertierung (f√ºr WebAuthn) ===
function base64urlToUint8Array(base64urlString) {
  const padding = '='.repeat((4 - (base64urlString.length % 4)) % 4);
  const base64 = (base64urlString + padding).replace(/-/g, '+').replace(/_/g, '/');
  const rawData = window.atob(base64);
  const outputArray = new Uint8Array(rawData.length);
  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  return outputArray;
}

function toBase64Url(buffer) {
  const bytes = new Uint8Array(buffer);
  let str = '';
  for (let i = 0; i < bytes.byteLength; i++) {
    str += String.fromCharCode(bytes[i]);
  }
  return btoa(str).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}

// === UI Aktualisierung nach Login ===
async function updateUIAfterLogin(user) {
    console.log("üîê updateUIAfterLogin aufgerufen:", user);

    if (!user) {
        console.warn('‚ö†Ô∏è Kein Benutzerobjekt √ºbergeben an updateUIAfterLogin');
        return;
    }

    loggedInUser = user;
    // üí° KORREKTUR: ADMIN hat dieselben Rechte wie Vorarbeiter
    isVorarbeiterGlobal = user.rolle === 'vorarbeiter' || user.rolle === 'admin';
    qrScanErfolgt = isVorarbeiterGlobal; // Vorarbeiter/Admin brauchen kein QR-Gate

    // Benutzername anzeigen
    const nameEl = document.getElementById('user-name');
    if (nameEl) {
        nameEl.textContent = user.name || user.email || 'Benutzer';
    }

    // Auth-Container ausblenden
    const authContainer = document.getElementById('auth-container');
    if (authContainer) {
        authContainer.classList.add('hidden');
        authContainer.setAttribute('aria-hidden', 'true');
    }

    // App-Ansicht anzeigen
    const appView = document.getElementById('app-view');
    if (appView) {
        appView.classList.remove('hidden');
        appView.setAttribute('aria-hidden', 'false');
    }

    // QR-Generator (nur f√ºr Vorarbeiter/Admin)
    const qrGen = document.getElementById('qr-generator-container');
    if (qrGen) {
        qrGen.classList.toggle('hidden', !isVorarbeiterGlobal);
        qrGen.setAttribute('aria-hidden', String(!isVorarbeiterGlobal));
    }

    // QR-Reader (nur f√ºr normale Nutzer)
    const qrReader = document.getElementById('qr-reader');
    if (qrReader) {
        qrReader.classList.toggle('hidden', isVorarbeiterGlobal);
        qrReader.setAttribute('aria-hidden', String(isVorarbeiterGlobal));
    }

    // QR-Section ggf. entfernen (f√ºr Vorarbeiter/Admin)
    const qrSection = document.getElementById('qr-section');
    if (isVorarbeiterGlobal && qrSection) {
        // Beim ersten Mal entfernen, danach ist es weg.
        if (qrSection.parentNode) {
             qrSection.remove();
        }
    }

    // Navigation & Logout anzeigen
    if (logoutBtn) logoutBtn.classList.remove('hidden');
    const bottomNav = document.getElementById('bottom-nav');
    if (bottomNav) bottomNav.classList.remove('hidden');

    // === QR-Logik & Sichtbare Section ===
    if (isVorarbeiterGlobal || qrScanErfolgt) {
        await hideQrGate();
        showSection('zeiterfassung-section');
    } else {
        await showQrGate();
        showSection('qr-section');
    }

    // === Aktuellen Zeitstatus vom Server holen ===
    try {
        const status = await apiFetch('/api/zeit/letzter-status');
        const eingestempelt = status.eingestempelt;
        const letzteAktion = status.letzteAktion; // z.B. 'start', 'stop', 'pause'

        const timeMessage = document.getElementById('time-message');

        if (eingestempelt) {
            console.log("‚úÖ Bereits eingestempelt (letzte Aktion):", letzteAktion);
            if (clockInBtn) clockInBtn.disabled = true;
            if (clockOutBtn) clockOutBtn.disabled = false;
            if (timeMessage) {
                timeMessage.textContent = `Du bist aktuell eingestempelt (letzte Aktion: ${letzteAktion}).`;
            }
        } else {
            console.log("üïí Noch nicht eingestempelt.");
            if (clockInBtn) clockInBtn.disabled = false;
            if (clockOutBtn) clockOutBtn.disabled = true;
            if (timeMessage) {
                timeMessage.textContent = "Noch nicht eingestempelt.";
            }
        }
    } catch (err) {
        console.error("‚ùå Fehler beim Laden des Zeitstatus:", err);
        const timeMessage = document.getElementById('time-message');
        if (timeMessage) timeMessage.textContent = "Fehler beim Laden des Zeitstatus.";
    }
}

// === Logout Cleanup ===
function handleLogoutCleanup() {
  loggedInUser = null;

  const loginForm = document.getElementById('login-form');
  if (loginForm) {
    if (loginForm['email']) loginForm['email'].value = '';
    if (loginForm['passwort']) loginForm['passwort'].value = '';
  }

  // Tokens aus Speicher l√∂schen
  sessionStorage.removeItem('accessToken');
  localStorage.removeItem('csrfToken');
  document.cookie = 'csrfToken=; Max-Age=0; path=/; secure; SameSite=None';

  // Alle Haupt-Sections ausblenden, au√üer Login-View
  [
    document.getElementById('qr-section'),
    document.getElementById('register-view'),
    document.getElementById('time-tracking-section'),
    document.getElementById('mein-tag-section'),
    document.getElementById('arbeitsplanung-section'),
    document.getElementById('zeiterfassung-section'),
    document.getElementById('chat-section'),
    document.getElementById('settings-section'),
    document.getElementById('qr-generator-section')
  ].filter(Boolean).forEach(sec => {
    if (sec.id !== 'login-view') {
      sec.classList.add('hidden');
      sec.setAttribute('aria-hidden', 'true');
    }
  });

  // Login-View anzeigen
  const loginView = document.getElementById('login-view');
  if (loginView) {
    loginView.classList.remove('hidden');
    loginView.setAttribute('aria-hidden', 'false');
  }

  // WICHTIG: auth-container sichtbar machen
  const authContainer = document.getElementById('auth-container');
  if (authContainer) {
    authContainer.classList.remove('hidden');
    authContainer.setAttribute('aria-hidden', 'false');
  }

  // Benutzername leeren
  const userNameSpan = document.getElementById('user-name');
  if (userNameSpan) userNameSpan.textContent = '';

  // Buttons zur√ºcksetzen, falls definiert
  if (typeof clockInBtn !== 'undefined') clockInBtn.disabled = false;
  if (typeof clockOutBtn !== 'undefined') clockOutBtn.disabled = true;

  // QR-Code-Generator verstecken
  const qrGen = document.getElementById('qr-generator-section');
  if (qrGen) qrGen.classList.add('hidden');

  // Bottom-Navigation ausblenden
  const bottomNav = document.getElementById('bottom-nav');
  if (bottomNav) bottomNav.classList.add('hidden');

  // Logout-Button verstecken
  if (typeof logoutBtn !== 'undefined') logoutBtn.classList.add('hidden');

  // QR-Scanner ggf. neu starten
  if (typeof initQRScanner === 'function') {
    initQRScanner();
  }
}

// === Logout ===
logoutBtn.addEventListener('click', async () => {
  try {
    await apiFetch('/api/logout', { method: 'POST' });
    handleLogoutCleanup();
    alert('Logout erfolgreich!');
  } catch (err) {
    console.error(err);
    alert('Logout Fehler: ' + err.message);
  }
});

// === Register-Link im Login-Form ===
showRegisterBtn.addEventListener('click', () => {
  showSection(registerSection);
});

// === Zur√ºck zum Login ===
showLoginBtn.addEventListener('click', () => {
  showSection(loginSection);
});

// === Registrierung ===
registerForm.addEventListener('submit', async (ev) => {
  ev.preventDefault();

  const vorname = registerForm['firstname'].value.trim();
  const nachname = registerForm['lastname'].value.trim();
  const email = registerForm['email'].value.trim();
  const passwort = registerForm['passwort'].value.trim();

  try {
    const res = await apiFetch('/api/register', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ vorname, nachname, email, passwort }),
    });

    // Wenn erfolgreich, bekommst du direkt das JSON mit message z.‚ÄØB.
    alert(res.message || 'Registrierung erfolgreich! Bitte einloggen.');
    showSection(loginSection);
  } catch (err) {
    alert(err.message || 'Registrierung fehlgeschlagen.');
  }
});

document.getElementById('show-register-btn').onclick = () => {
  document.getElementById('login-view').classList.add('hidden');
  document.getElementById('register-view').classList.remove('hidden');
};

document.getElementById('show-login-btn').onclick = () => {
  document.getElementById('register-view').classList.add('hidden');
  document.getElementById('login-view').classList.remove('hidden');
};
  
// === Zeit erfassen (Start) ===
// === Zeit erfassen (Start & danach sofort Logout) ===
clockInBtn.addEventListener('click', async () => {
  if (!loggedInUser) {
    alert('Bitte zuerst einloggen');
    return;
  }

  clockInBtn.disabled = true;

  try {
    await apiFetch('/api/zeit', {
      method: 'POST',
      body: JSON.stringify({ aktion: 'start' }),
    });

    alert('‚úÖ Du wurdest erfolgreich eingestempelt.\nDu wirst jetzt ausgeloggt.');

    // Logout durchf√ºhren
    await apiFetch('/api/logout', { method: 'POST' });

    // UI aufr√§umen und zur√ºck zur QR/Loginmaske
    handleLogoutCleanup();
  } catch (err) {
    console.error('Fehler beim Start der Arbeitszeit oder beim Logout:', err);
    alert('Fehler: ' + err.message);
    clockInBtn.disabled = false; // Nur bei Fehler wieder aktivieren
  }
});

// === Zeit erfassen (Stopp) ===
// === Zeit erfassen (Stopp & danach sofort Logout) ===
clockOutBtn.addEventListener('click', async () => {
  if (!loggedInUser) {
    alert('Bitte zuerst einloggen');
    return;
  }

  clockOutBtn.disabled = true;

  try {
    await apiFetch('/api/zeit', {
      method: 'POST',
      body: JSON.stringify({ aktion: 'stop' }),
    });

    alert('‚èπÔ∏è Du wurdest erfolgreich ausgestempelt.\nDu wirst jetzt ausgeloggt.');

    // Logout durchf√ºhren
    await apiFetch('/api/logout', { method: 'POST' });

    // UI aufr√§umen und zur√ºck zur QR/Loginmaske
    handleLogoutCleanup();
  } catch (err) {
    console.error('Fehler beim Stoppen der Arbeitszeit oder beim Logout:', err);
    alert('Fehler beim Stoppen der Arbeitszeit: ' + err.message);
  }
});

  //schon eingestempelt?
async function getLetzterStatus() {
  try {
    const data = await apiFetch('/api/zeit/letzter-status', {
      method: 'GET',
      headers: {
        'Accept': 'application/json',
      },
    }, true); // Authentifizierung aktivieren

    console.log('Letzter Zeitstatus:', data);
    return data; // z.B. { aktion: 'start', zeit: '2025-06-09T08:00:00Z' }
  } catch (err) {
    console.error('Fehler beim Abrufen des letzten Status:', err);
    return null;
  }
}
  
  document.addEventListener("DOMContentLoaded", () => {
 
  // Alle Sections als Array (f√ºr showSection)
  const sections = [
    meinTagSection,
    arbeitsplanungSection,
    zeiterfassungSection,
    chatSection,
    settingsSection,
    qrSection
  ].filter(Boolean);

  // === Navigation Button Handler ===
navButtons.forEach((btn) => {
  btn.addEventListener("click", async () => {
    const targetId = btn.dataset.target;

    // Kein Ziel oder gesch√ºtzte Bereiche
    if (!targetId || targetId === "login-view") return;

    // Vorarbeiter d√ºrfen nicht zur QR-Section
    if (targetId === "qr-section" && isVorarbeiterGlobal) return;

    // Special Case: Zeiterfassung
    if (targetId === "zeiterfassung-section") {
      if (isVorarbeiterGlobal) {
        await hideQrGate();
        showSection('zeiterfassung-section');
        setActiveNavButton(btn);
      } else {
        if (qrScanErfolgt) {
          await hideQrGate();
          showSection('zeiterfassung-section');
          setActiveNavButton(btn);
        } else {
          await showQrGate(); // Zeigt QR-Gate, aber kein Sectionwechsel
          setActiveNavButton(null); // Kein Button aktiv
        }
      }
    } else {
      await hideQrGate();

      // QR-Section absichern
      if (isVorarbeiterGlobal && targetId === 'qr-section') return;

      const targetSection = document.getElementById(targetId);
      if (targetSection) {
        showSection(targetSection);
        setActiveNavButton(btn);
      } else {
        console.warn("‚ö†Ô∏è Zielsection nicht gefunden:", targetId);
      }
    }
  });
});

/**
 * Setzt den "active"-Status f√ºr den geklickten Button.
 * Wenn `null` √ºbergeben wird, wird der Status f√ºr alle entfernt.
 */
function setActiveNavButton(activeBtn) {
  navButtons.forEach(btn => btn.classList.remove('active'));
  if (activeBtn) {
    activeBtn.classList.add('active');
  }
}
});
  
</script>

</body>
</html>




































